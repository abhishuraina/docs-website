---
title: "Knowledge Integration API"
metaDescription: "Integration of RAG with Confluence is a GenAI assistant for observability that will help you understand and improve your system by integrating RAG with your confluence"
tags:
freshnessValidatedDate: never
---

Knowlegde APIs are used to integrate Knowledge API's with Confluence. The integration of Knowledge API's with Confluence is an assistant for observability that will help you understand and improve your system by integrating Knowledge API's with your Confluence.

## Generic Types

```graphql
extend schema @link(
  url: "https://specs.apollo.dev/federation/v2.0",
  import: ["@key", "@sharable"]
)

"Scalar for unix timestamp"
scalar EpochMilliseconds
```
## Tools

**Namespace**: MachineLearning

```graphql
"Metadata about a tool"
type RagTool @key(fields:"id") {
  "ID of the Tool"
  id: ID!
  "Organization that owns this"
  organizationId: ID
  "Account that owns this"
  accountId: Int!
  "Creator of this"
  creatorId: ID!
  "Time created"
  createdAt: EpochMilliseconds!
  "Modified time"
  modifiedAt: EpochMilliseconds!
  "Indicates whether or not the document has been deactivated"
  deactivated: Boolean!
  "The category of the tool - eg RAG, API"
  category: String!
  "The type of tool - eg CONFLUENCE, GITHUB"
  type: String!
  "Display Name of the tool"
  displayName: String!
  "Description of the tool"
  description: String!
  "Interval the indexer will run at (if configured)"
  interval: String
  "Configuration for the indexer (if configured)"
  indexerConfiguration: [{ key: String, value: String }]
  "Last Index Time (if configured)"
  lastIndexTime: EpochMilliseconds
  "Next Index Time (if configured)"
  nextIndexTime: EpochMilliseconds
}
```
## Document

**Namespace**: MachineLearning

```graphql
"Metadata about a RAG document"
type RagDocument @key(fields:"id") {
  "ID of the Document"
  id: ID!
  "Organization that owns this"
  organizationId: ID
  "Account that owns this"
  accountId: Int!
  "Creator of this"
  creatorId: ID!
  "Time created"
  createdAt: EpochMilliseconds!
  "Indicates whether or not the document has been deactivated"
  deactivated: Boolean!
  "Name of the file"
  filename: String!
  "Source of the file"
  source: String!
  "ID of the blob"
  blobId: ID!
  "Ids of the authors"
  authorIds: [ID]
  "Ids of related entities"
  entityIds: [ID]
  "Emails of the authors"
  authorEmails: [String]
}
```

## NraiMLTag

```graphql
type NraiMLTag @key(fields: "id") {
  "ID of the tag"
  id: ID!
  "Organization that owns this"
  organizationId: ID
  "Account that owns this"
  accountId: Int!
  "Creator of this"
  creatorId: ID!
  "Time created"
  createdAt: EpochMilliseconds!
  "Time last modified"
  modifiedAt: EpochMillisconds!
  "Name of the tag"
  tag: String!
  "description of the tag"
  description: String!
  "Optional parent ID for the tag; allows for heirarchical organization"
  parent: ID
}
```

## NraiMLAppliedTag

```graphql
"Applied Tag"
type NraiMLAppliedTag {
  "The id of the applied tag"
  id: ID!
  "Organization that owns this"
  organizationId: ID
  "Account that owns this"
  accountId: Int!
  "Creator of this"
  creatorId: ID!
  "Time created"
  createdAt: EpochMilliseconds!
  "Time last modified"
  modifiedAt: EpochMillisconds!
  "Tag ID"
  tagId: ID!
  "The type of the target for the applied tag"
  targetType: String!
  "The id of the target for the applied tag"
  targetId: ID!
}
```

## NraiMLTagConnection

```graphql
"Cursor pagination for Tags"
type NraiMLTagConnection {
  "Next cursor to paginate by"
  nextCursor: String
  "Previous cursor to paginate by"
  prevCursor: String
  "Indicates whether or not there is a next page"
  hasNextPage: Boolean
  "Indicates whether or not there is a previous page"
  hasPrevPage: Boolean
  "Total Count of results"
  totalCount: Int
  "Array of results"
  entities: [NraiMLTag]
}
```

## RAG Document Connection

**Namespace**: MachineLearning

```graphql
type RagDocumentConnection {
  "Next cursor to paginate by"
  nextCursor: String
  "Previous cursor to paginate by"
  prevCursor: String
  "Indicates whether there is a next page"
  hasNextPage: Boolean
  "Indicates whether there is a previous page"
  hasPrevPage: Boolean
  "Total count of results"
  totalCount: Int
  "Array of results"
  entities: [Document]
}
```
## RAG Tool Connection

**Namespace**: MachineLearning

```graphql
type RagToolConnection {
  "Next cursor to paginate by"
  nextCursor: String
  "Previous cursor to paginate by"
  prevCursor: String
  "Indicates whether there is a next page"
  hasNextPage: Boolean
  "Indicates whether there is a previous page"
  hasPrevPage: Boolean
  "Total count of results"
  totalCount: Int
  "Array of results"
  entities: [RagTool]
}
```
## Create RAG Tool

**Namespace**: MachineLearning

```graphql
type Mutation {
  createRagTool {
    "The account ID that owns the tool"
    accountId: Int!
    "The type of tool, e.g., CONFLUENCE, GITHUB"
    type: String!
    "Display name of the tool"
    displayName: String!
    "Description of the tool"
    description: String!
    "Configuration for the tool"
    configuration: [{ key: String, value: String }]
    "Indicates if a pull from the indexer is needed"
    needsPull: Boolean!
    "Interval the indexer will run at, e.g., HOURLY, DAILY, WEEKLY"
    interval: String
    "Configuration for the indexer"
    indexerConfiguration: [{ key: String, value: String }]
  }: Tool
}
```

## Create Document

**Namespace**: MachineLearning

```graphql
type Mutation {
  createRagDocument {
    "Name of the document"
    name: String!
    "Description of the document"
    description: String!
    "Source URL of the document"
    sourceUrl: String
    "ID of the tool"
    toolId: ID!
    "Author emails"
    authorEmails: [String]
    "Associated entity IDs"
    entityIds: [ID]
  }: RagDocument
}
```

## Update Document

**Namespace**: MachineLearning

```graphql
type Mutation {
  updateRagDocument {
    "ID of the document"
    id: ID!
    "Name of the document"
    name: String!
    "Description of the document"
    description: String!
    "Source URL of the document"
    sourceUrl: String
    "ID of the tool"
    toolId: ID!
    "Author emails"
    authorEmails: [String]
    "Associated entity IDs"
    entityIds: [ID]
  }: RagDocument
}
```

## Delete Document

**Namespace**: MachineLearning

```graphql
type Mutation {
  deleteRagDocument {
    "ID of the document"
    id: ID!
  }: RagDocument
}
```

## Document by IDs

**Namespace**: MachineLearning

```graphql
type AccountStitchedFields {
  "Get RAG documents by IDs"
  RagDocumentsByIds(
    "Array of document IDs"
    ids: [ID]!
  ): [RagDocument]
}
```

## Documents by Tool ID

**Namespace**: MachineLearning

```graphql
type AccountStitchedFields {
  "Get RAG documents by tool ID"
  RagDocumentsByToolId(
    "Tool ID"
    toolId: String!
  ): RagDocumentConnection
}
```

## Documents by Tag

**Namespace**: MachineLearning

```graphql
type AccountStitchedFields {
  "Get RAG documents by tag"
  RagDocumentsByTag(
    "Tag"
    tag: String!
  ): RagDocumentConnection
}
```

## Documents by Entity ID

**Namespace**: MachineLearning

```graphql
type AccountStitchedFields {
  "Get RAG documents by associated entity ID"
  RagDocumentsByEntityId(
    "Entity ID"
    ID: ID!
  ): RagDocumentConnection
}
```

## Documents by Author Email

**Namespace**: MachineLearning

```graphql
type AccountStitchedFields {
  "Get RAG documents by author email"
  RagDocumentsByAuthorEmail(
    "Author email"
    email: String!
  ): RagDocumentConnection
}
```

## Tools

**Namespace**: MachineLearning

```graphql
type AccountStitchedFields {
  "Get RAG tools"
  RagTools(): RagToolConnection
}
```

## Tools by IDs

**Namespace**: MachineLearning

```graphql
type AccountStitchedFields {
  "Get RAG tools by IDs"
  RagToolsByIds(
    "Array of tool IDs"
    ids: [ID]!
  ): [RagTool]
}
```